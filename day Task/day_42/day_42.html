<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 42</title>
</head>
<body>
    
</body>

<script>
	/*
    
class Node
{
	constructor(data)
	{
		this.data = data;
		this.left = null;
		this.right = null;
	}
    
}

class BinarySearchTree
{
	constructor(root)
	{
		
		this.root = null;
	}

	
				

insert(data)
{
	
	var newNode = new Node(data);
					
	
	if(this.root === null)
		this.root = newNode;
	else

		
		this.insertNode(this.root, newNode);
}


insertNode(node, newNode)
{
	
	if(newNode.data < node.data)
	{
		
		if(node.left === null)
			node.left = newNode;
		else

			
			this.insertNode(node.left, newNode);
	}

	
	else
	{
		
		if(node.right === null)
			node.right = newNode;
		else

			
			this.insertNode(node.right,newNode);
	}
}

remove(data)
{
	
	this.root = this.removeNode(this.root, data);
}


removeNode(node, key)
{
		
	
	if(node === null)
		return null;

	
	else if(key < node.data)
	{
		node.left = this.removeNode(node.left, key);
		return node;
	}

	
	else if(key > node.data)
	{
		node.right = this.removeNode(node.right, key);
		return node;
	}

	
	else
	{
		
		if(node.left === null && node.right === null)
		{
			node = null;
			return node;
		}

		
		if(node.left === null)
		{
			node = node.right;
			return node;
		}
		
		else if(node.right === null)
		{
			node = node.left;
			return node;
		}

		
		var aux = this.findMinNode(node.right);
		node.data = aux.data;

		node.right = this.removeNode(node.right, aux.data);
		return node;
	}

}

inorder(node)
{
	if(node !== null)
	{
		this.inorder(node.left);
		console.log(node.data);
		this.inorder(node.right);
	}
}

preorder(node)
{
	if(node !== null)
	{
		console.log(node.data);
		this.preorder(node.left);
		this.preorder(node.right);
	}
}

postorder(node)
{
	if(node !== null)
	{
		this.postorder(node.left);
		this.postorder(node.right);
		console.log(node.data);
	}
}

findMinNode(node)
{
	
	if(node.left === null)
		return node;
	else
		return this.findMinNode(node.left);
}

getRootNode()
{
	return this.root;
}

search(node, data)
{

	if(node === null)
		return null;

	
	else if(data < node.data)
		return this.search(node.left, data);

	
	else if(data > node.data)
		return this.search(node.right, data);

	
	else
		return node;
}

var root = new BinarySearchTree();


BST.insert(15);
BST.insert(25);
BST.insert(10);
BST.insert(7);
BST.insert(22);
BST.insert(17);
BST.insert(13);
BST.insert(5);
BST.insert(9);
BST.insert(27);
						


var root = BST.getRootNode();
			

BST.inorder(root);
			

BST.remove(5);
			
			

			
						
var root = BST.getRootNode();
			

BST.inorder(root);
			

BST.remove(7);
			

			
			
var root = BST.getRootNode();


BST.inorder(root);
			

BST.remove(15);
	


var root = BST.getRootNode();
console.log("inorder traversal");


BST.inorder(root);
			
console.log("postorder traversal");
BST.postorder(root);
console.log("preorder traversal");
BST.preorder(root);


}

*/

    
class Node
{
	constructor(data)
	{
		this.data = data;
		this.left = null;
		this.right = null;
	}
    
}

class BinarySearchTree
{
	constructor(root)
	{
		
		this.root = null;
	}

insert(data)
{
	
	var newNode = new Node(data);
					
	
	if(this.root === null)
		this.root = newNode;
	else

		
		this.insertNode(this.root, newNode);
}

insertNode(node, newNode)
{
	
	if(newNode.data < node.data)
	{
		
		if(node.left === null)
			node.left = newNode;
		else

			
			this.insertNode(node.left, newNode);
	}
	
	else
	{
		
		if(node.right === null)
			node.right = newNode;
		else

			
			this.insertNode(node.right,newNode);
	}
}

remove(data)
{
	
	this.root = this.removeNode(this.root, data);
}

removeNode(node, key)
{
		
	
	if(node === null)
		return null;

	
	else if(key < node.data)
	{
		node.left = this.removeNode(node.left, key);
		return node;
	}

	
	else if(key > node.data)
	{
		node.right = this.removeNode(node.right, key);
		return node;
	}

	
	else
	{
		
		if(node.left === null && node.right === null)
		{
			node = null;
			return node;
		}

		
		if(node.left === null)
		{
			node = node.right;
			return node;
		}
		
		else if(node.right === null)
		{
			node = node.left;
			return node;
		}

		
		var aux = this.findMinNode(node.right);
		node.data = aux.data;

		node.right = this.removeNode(node.right, aux.data);
		return node;
	}

}

inorder(node)
{
	if(node !== null)
	{
		this.inorder(node.left);
		console.log(node.data);
		this.inorder(node.right);
	}
}

preorder(node)
{
	if(node !== null)
	{
		console.log(node.data);
		this.preorder(node.left);
		this.preorder(node.right);
	}
}

postorder(node)
{
	if(node !== null)
	{
		this.postorder(node.left);
		this.postorder(node.right);
		console.log(node.data);
	}
}

findMinNode(node)
{
	
    let current = node;
	if (node === null) 
        return current;
    if(node.left===null)
       return current;
    if(node.left.data<current.data){
        current=node.left;
        return this.findMaxNode(node.left)
    }
}
findMaxNode(node)
{
    let current = node;
	if (node === null) 
        return current;
    if(node.right===null)
       return current;
    if(node.right.data>current.data){
        current=node.right;
        return this.findMaxNode(node.right)
    }
}

getRootNode()
{
	return this.root;
}

search(node, data)
{

	if(node === null)
		return null;

	
	else if(data < node.data)
		return this.search(node.left, data);

	
	else if(data > node.data)
		return this.search(node.right, data);

	
	else
		return node;
}
}

var BST = new BinarySearchTree();


BST.insert(15);
BST.insert(25);
BST.insert(10);
BST.insert(7);
BST.insert(22);
BST.insert(17);
BST.insert(13);
BST.insert(5);
BST.insert(9);
BST.insert(27);
						

console.log("Binary Search Tree")
var root = BST.getRootNode();
BST.inorder(root);	

console.log("Binary Search Tree after Deletion 5")	
BST.remove(5);	
console.log("The root val for BST : ", root.data)							
var root = BST.getRootNode();	
BST.inorder(root);

console.log("Binary Search Tree after Deletion 7")
BST.remove(7);		
console.log("The root val for BST : ", root.data)	
var root = BST.getRootNode();
BST.inorder(root);

console.log("Binary Search Tree after Deletion 15")
BST.remove(15)
console.log("The root val for BST : ", root.data)	
var root = BST.getRootNode();
BST.inorder(root);

console.log("inorder traversal");
console.log("The root val for BST : ", root.data)
BST.inorder(root);
			
console.log("postorder traversal");
console.log("The root val for BST : ", root.data)
BST.postorder(root);

console.log("preorder traversal");
console.log("The root val for BST : ", root.data)
BST.preorder(root)

console.log(" The Minimum Value in the tree is :",BST.findMinNode(root))
console.log(" The Maximum Value in the tree is :",BST.findMaxNode(root))




</script>
</html>